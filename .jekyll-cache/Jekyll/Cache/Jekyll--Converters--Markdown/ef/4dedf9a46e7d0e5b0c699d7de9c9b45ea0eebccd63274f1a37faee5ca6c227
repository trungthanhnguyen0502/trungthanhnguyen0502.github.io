I".E<ul>
  <li><a href="#-algorithm">1. Ý tưởng thuật toán</a></li>
  <li><a href="#-code">2. Code thôi</a></li>
</ul>

<div class="imgcap">
    <div>
        <img src="/assets/4-visualize/result.png" width="300" />
    </div>
    <div class="thecap">H1  </div>
</div>
<hr />

<p>Khi làm việc với các deep learning, đặc biệt với các CNN model, ta biết rằng tại mỗi layer với các filter có khả năng nhận dạng từng loại đặc trưng khác nhau trong ảnh input. Càng về các layer cuối, thông tin mà model thu được từ input sẽ được trìu tượng hóa cao hơn (hay trích xuất thông tin ở mức phức tạp hơn). Tuy nhiên làm thế nào để biết được từng filter nhận diện loại feature nào?  Hôm nay, mình sẽ viết về thuật toán Visualize Filter để giải quyết vấn đề đó. Hơn nữa, đây cũng là thuật toán cơ sở, tiền đề cho các thuật toán cao cấp hơn như Style Transfer, Deep Dream …(các thuật toán liên quan tới biến đổi ảnh đầu vào).</p>

<p>Github: <a href="https://github.com/trungthanhnguyen0502/Visualize-filter-deepnet">github: trungthanhnguyen0502</a></p>

<!-- Ý tưởng về thuật toán -->
<p><a name="#-algorithm"></a></p>

<h2 id="1thuật-toán">1.Thuật toán:</h2>

<div class="imgcap">
    <div>
        <img src="/assets/4-visualize/algorithm.png" width="700" />
    </div>
    <div class="thecap">H2: Tổng quan về thuật toán  </div>
</div>
<hr />

<p>Thuật toán:</p>
<ul>
  <li>Tạo một ảnh nhiễu input_img bất kì</li>
  <li>
    <p>Đưa input_img vào model, tại 1 layer lấy ra feature_map tương ứng với Filter cần quan sát. Mục tiêu sau nhiều step, input_img sẽ được biến đổi sao cho giá trị feature_map đạt giá trị lớn nhất. Khi đó input_img sẽ đại diện các đường nét, màu sắc mà Filter đó đạt tối đa khả năng trích xuất.</p>
  </li>
  <li>Tính đạo hàm mean(feature_map) theo biến input_img</li>
  <li>update input_img theo thuật toán gradient_descent, để maximum giá trị mean(feature_map) thì update giá trị input_img với phép cộng thay vì phép trừ thường thấy ở gradient_descent, công thức:</li>
</ul>

\[img = img + lr * gradient\]

<p>Ok, tiến hành code thôi</p>

<p><a name="-code"></a></p>

<h2 id="2-code">2. Code</h2>

<p>Mình sẽ dùng 1 phiên bản pretrain VGG16 để minh họa thuật toán. Sau khi hiểu thuật toán, mọi người hoàn toàn có thể dùng 1 pretrain CNN bất kì khác, có thể code bằng tensorflow, keras hoặc pytorch.</p>

<p>Để dùng được phiên bản VGG này, mọi người chỉ cần vào <a href="https://github.com/trungthanhnguyen0502/Visualize-filter-deepnet">github</a> và download code của mình về,
Project gồm:</p>
<ul>
  <li>vgg16.py:     chứa code và các hàm liên quan tới vgg16</li>
  <li>download.py:  để auto download vgg16.</li>
  <li>main.ipynb : Toàn bộ code của thuật toán (thứ cần đọc).</li>
</ul>

<p><strong>Load và tạo model</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>vgg16.maybe_download()
vgg = vgg16.VGG16()
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Các hàm tiền xử lí, hậu xử lí ảnh</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">normalize_image</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s">"""
    Chuẩn hoá giá trị các pixel ảnh về [0,1]
    """</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nb">min</span><span class="p">()</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nb">max</span><span class="p">()</span>
    <span class="n">x_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_norm</span>

<span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">img_norm</span> <span class="o">=</span> <span class="n">normalize_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="k">def</span> <span class="nf">plot_images</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
    <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">normalize_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="p">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span> 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Trích xuất ra feature_map tại với layer_index và filter_index (tại 1 layer có nhiều filter khác nhau). Mean(feature_map) là giá trị chúng ta cần maximum.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">layer_id</span><span class="p">,</span> <span class="n">feature_id</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">model</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">as_default</span><span class="p">():</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">get_layer_tensors</span><span class="p">([</span><span class="n">layer_id</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">feature_map</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[:,:,:,</span><span class="n">feature_id</span><span class="p">]</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">feature_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>Visualize</strong>: tính đạo hàm và update input:</p>
<ul>
  <li>Tensorflow cung cấp tf.gradient(loss, tensor) để tính gradient của loss theo 1 biến tensor (giống như tính đạo hàm F(x) theo biến x)</li>
  <li>Để đảm bảo giá trị thay đổi trong mỗi step không quá lớn hoặc quá nhỏ, ta sử dụng thuật toán tính learning rate, với stepsize được coi là giá trị khởi tạo learning rate:</li>
</ul>

\[lrate = \frac{stepsize}{(gradient.max() + 1e-8)}\]

<ul>
  <li>Ngoài gradient.max(), ta có thể dùng gradient.std()</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="c1"># Hàm chính, nhận model, layer index, filter index, trả về generate_image là kết quả bài toán
</span><span class="k">def</span> <span class="nf">visual</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">layer_id</span><span class="p">,</span> <span class="n">feature_id</span><span class="p">,</span> <span class="n">iters</span><span class="p">,</span><span class="n">step_size</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>

    <span class="c1"># khởi tạo 1 ảnh nhiễu bất kì
</span>    <span class="n">generate_img</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">224</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mf">128.0</span>

    <span class="k">with</span> <span class="n">model</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">as_default</span><span class="p">():</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">vgg</span><span class="p">,</span> <span class="n">layer_id</span><span class="p">,</span> <span class="n">feature_id</span><span class="p">)</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">gradients</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="nb">input</span><span class="p">)</span>
        
        <span class="c1"># feed_dict là input tensor chứa ảnh input đầu vào
</span>        <span class="n">feed_dict</span> <span class="o">=</span> <span class="n">vgg</span><span class="p">.</span><span class="n">create_feed_dict</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">generate_img</span><span class="p">)</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">Session</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">vgg</span><span class="p">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">global_variables_initializer</span><span class="p">()</span>
        <span class="n">session</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
            <span class="n">grad_val</span><span class="p">,</span> <span class="n">loss_val</span> <span class="o">=</span> <span class="n">session</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="n">gradient</span><span class="p">,</span> <span class="n">loss</span><span class="p">],</span> <span class="n">feed_dict</span><span class="o">=</span><span class="n">feed_dict</span><span class="p">)</span>
            <span class="n">grad_val</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">grad_val</span><span class="p">).</span><span class="n">squeeze</span><span class="p">()</span>
            
            <span class="c1"># tính learning rate
</span>            <span class="n">lrate</span> <span class="o">=</span> <span class="n">step_size</span><span class="o">/</span><span class="p">(</span><span class="n">grad_val</span><span class="p">.</span><span class="nb">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
            <span class="n">generate_img</span> <span class="o">+=</span> <span class="n">lrate</span> <span class="o">*</span> <span class="n">grad_val</span>
        <span class="k">return</span> <span class="n">generate_img</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Run code demo:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">feature_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">layer_id</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">for</span> <span class="n">f_id</span> <span class="ow">in</span> <span class="n">feature_ids</span><span class="p">:</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">visual</span><span class="p">(</span><span class="n">vgg</span><span class="p">,</span> <span class="n">layer_id</span><span class="p">,</span> <span class="n">f_id</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">images</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">plot_images</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Kết quả thu được như dưới, có thể hiểu rằng tại layer thứ 5, filter đầu tiên có khả năng trích xuất các đường nét tròn tròn, filter thứ 2 trích xuất các đường nét cong cong nhưng theo hướng xếp thẳng đứng ….</p>

<div class="imgcap">
    <div>
        <img src="/assets/4-visualize/result2.png" width="700" />
    </div>
    <div class="thecap">H3: Kết quả thu được  </div>
</div>
:ET